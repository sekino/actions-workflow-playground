name: adhoc terraform execute

on:
  issue_comment:
    types: [ created ]
  pull_request:
    branches:
      - main
    types: [closed]

env:
  PLAN_ROLE_MAP: '{ "dev": "role/terraformPlan", "stg": "role/terraformPlan" }'
  APPLY_ROLE_MAP: '{ "dev": "role/terraformApply", "stg": "role/terraformApply" }'
  # bitwarden: Mongo Atlas API Key terraform
  ATLAS_API_KEY_ID_MAP: '{ "dev": "123456", "stg": "78910" }'

jobs:
  create-context-plan:
    if: ${{ github.event.comment.body && startsWith(github.event.comment.body, '/target') }}
    runs-on: ubuntu-22.04
    steps:
      - name: Create context
        id: create-context
        run: |
          echo -n "${{ github.event.comment.body }}"

#          target_lines=$(echo -n "${{ github.event.comment.body }}" | grep -E -w 'plan|plan-destroy')
#          target_env=$(echo -n "${target_lines}" | grep -E -ow 'dev|stg|prd|sbg' | sort | uniq)
          
#          target_line_num=$(echo -n ${target_lines} | wc -l | tr -d ' ')
#          if [[ "${target_line_num}" == "0" ]]; then
#            echo "targets is empty"
#            exit 0
#          fi
          
#          target_env_num=$(echo -n ${target_env} | wc -l | tr -d ' ')
#          if [[ "${target_env_num}" == "0" ]]; then
#            echo "cannot find env in target" >&2
#            exit 1
#          fi
#          if [[ "${target_env_num}" != "1" ]]; then
#            echo "two or more env in target" >&2
#            exit 1
#          fi
#
#          context_array=() // { "target_path": <path>, "mode": <mode> } というフォーマットの文字列の配列
#          for target_line in ${target_lines}; do
#            mode="$(echo -n ${target_line} | cut -d ' ' -f1 | tr -d ' ')"
#            target_path="$(echo -n ${target_line} | cut -d ' ' -f2 | tr -d ' ' | sed -e "s%/$%%g")"
#            context_array+=("{ \"target_path\": \"${target_path}\", \"mode\": \"${mode}\" }")
#          done
#          context_json=$(path_list=$(jq --compact-output --null-input '$ARGS.positional' --args -- "${context_array[@]}"))
#
#          echo "target_env: ${target_env}"
#          echo "target_lines: ${target_lines}"
#
#          echo "contexts=${context_json}" >> $GITHUB_OUTPUT
#          echo "env=${target_env}" >> $GITHUB_OUTPUT
    outputs:
      contexts: ${{ steps.create-context.outputs.contexts }}
      env: ${{ steps.create-context.outputs.env }}

  call-plan:
    needs: create-context-plan
    strategy:
      matrix:
        context: ${{ fromJson(needs.create-context-plan.outputs.context) }}
    if: ${{ needs.create-context-plan.outputs.context }}
    runs-on: ubuntu-22.04
    steps:
      - name: demo
        run: |
          echo ${target_path}
          echo ${mode}
        env:
          target_path: ${{ matrix.context.target_path }}
          mode: ${{ matrix.context.mode }}
          env: ${{ needs.create-context-plan.outputs.env }}
          role-to-assume: ${{ fromJson(env.PLAN_ROLE_MAP)[needs.create-context-plan.outputs.env] }}
          atlas-api-key-id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-context-plan.outputs.env] }}

#  call-apply:
#    needs: create-tf-execute-context
#    if: ${{ github.event.pull_request.merged == true && needs.create-tf-execute-context.outputs.targets && needs.create-tf-execute-context.outputs.targets != '[]' }}
#    strategy:
#      matrix:
#        state_dir: ${{fromJson(needs.create-tf-execute-context.outputs.targets)}}
#    uses: ./.github/workflows/apply.yml
#    with:
#      role-to-assume: ${{ fromJson(env.APPLY_ROLE_MAP)[needs.create-tf-execute-context.outputs.env] }}
#      work-dir: ${{ matrix.state_dir }}
#      env: ${{ needs.create-tf-execute-context.outputs.env }}
#      atlas-api-key-id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-tf-execute-context.outputs.env] }}
#    secrets:
#      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
#      MODULE_TOKEN: ${{ secrets.MABOT_TOKEN }}
