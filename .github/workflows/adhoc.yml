name: adhoc terraform execute

on:
  issue_comment:
    types: [ created ]
  pull_request:
    branches:
      - main
    types: [closed]

env:
  PLAN_ROLE_MAP: '{ "dev": "role/terraformPlan", "stg": "role/terraformPlan" }'
  APPLY_ROLE_MAP: '{ "dev": "role/terraformApply", "stg": "role/terraformApply" }'
  # bitwarden: Mongo Atlas API Key terraform
  ATLAS_API_KEY_ID_MAP: '{ "dev": "123456", "stg": "78910" }'

jobs:
  get-target-comment:
    if: ${{ (github.event.comment.body && startsWith(github.event.comment.body, '/target')) || startsWith(github.event.comment.body, '/apply') }}
    runs-on: ubuntu-22.04
    steps:
      - name: when PR comment
        id: when-pr-comment
        if: ${{ (github.event.comment.body && startsWith(github.event.comment.body, '/target')) }}
        run: |
          echo "target_comment=${{ github.event.comment.body }}" >> $GITHUB_OUTPUT

      - name: when PR merge
        id: when-pr-merge
        if: startsWith(github.event.comment.body, '/apply')
        uses: actions/github-script@v6.3.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            })
            
            // 最新のtargetコメントを使用する
            const targetComment = comments.reverse().find(comment => {
              return comment.body.startsWith("bbb")
            })
            
            if (targetComment) return targetComment.body

      - name: Create output
        id: create-output
        run: |
          if [[ ! -z "${TARGET_COMMENT_WHEN_COMMENT}"]]; then
            echo "target_comment=${TARGET_COMMENT_WHEN_COMMENT}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [[ "${TARGET_COMMENT_WHEN_MERGE}" != "undefined" ]]; then
            echo "target_comment=${TARGET_COMMENT_WHEN_MERGE}" >> $GITHUB_OUTPUT
            exit 0
          fi
        env:
          TARGET_COMMENT_WHEN_COMMENT: ${{ steps.when-pr-comment.outputs.target_comment }}
          TARGET_COMMENT_WHEN_MERGE: ${{ steps.when-pr-merge.outputs.result }}
    outputs:
      target_comment: ${{ steps.create-output.outputs.target_comment }}


  create-context:
    needs: get-target-comment
    if: ${{ needs.get-target-comment.outputs.target_comment }}
    runs-on: ubuntu-22.04
    steps:
      - name: Create context
        shell: bash {0}
        id: create-context
        run: |
          target_lines=$(echo "${TARGET_COMMENT}" | grep -E -w 'plan|plan-destroy' | sort | uniq)
          target_env=$(echo "${target_lines}" | grep -E -ow 'dev|stg|prd|sbg' | sort | uniq)
          
          if [[ -z "${target_lines}" ]]; then
            echo "targets is empty"
            exit 0
          fi
          
          if [[ -z "${target_env}" ]]; then
            echo "cannot find env in target" >&2
            exit 1
          fi
          
          target_env_num=$(echo ${target_env} | wc -l | tr -d ' ')
          if [[ "${target_env_num}" != "1" ]]; then
            echo "two or more env in target" >&2
            exit 1
          fi

          context_array=()
          while IFS= read -r target_line; do
            mode="$(echo ${target_line} | cut -d ' ' -f1 | tr -d ' ')"
            target_path="$(echo ${target_line} | cut -d ' ' -f2 | tr -d ' ' | sed -e "s%/$%%g" | sed -e "s/[\r\n]\+//g" )"
            context="{ \"target_path\": \"${target_path}\", \"mode\": \"${mode}\" }"
            context_array+=("${context}")
          done <<< "${target_lines}" 
          context_json=$(jq --compact-output --null-input '$ARGS.positional' --args -- "${context_array[@]}")

          echo "target_env: ${target_env}"
          echo "target_lines: ${target_lines}"
          echo "contexts: ${context_json}"

          echo "contexts=${context_json}" >> $GITHUB_OUTPUT
          echo "env=${target_env}" >> $GITHUB_OUTPUT
        env:
          TARGET_COMMENT: ${{ needs.get-target-comment.outputs.target_comment }}

    outputs:
      contexts: ${{ steps.create-context.outputs.contexts }}
      env: ${{ steps.create-context.outputs.env }}

  call-plan:
    needs: create-context
    if: ${{ (github.event.comment.body && startsWith(github.event.comment.body, '/target')) }}
    strategy:
      matrix:
        context: ${{ fromJson(needs.create-context.outputs.contexts) }}
    runs-on: ubuntu-22.04
    steps:
      - name: demo call plan
        run: |
          echo ${target_path}
          echo ${mode}
          echo ${env}
          echo ${role_to_assume}
          echo ${atlas_api_key_id}
        env:
          target_path: ${{ fromJson(matrix.context).target_path }}
          mode: ${{ fromJson(matrix.context).mode }}
          env: ${{ needs.create-context.outputs.env }}
          role_to_assume: ${{ fromJson(env.PLAN_ROLE_MAP)[needs.create-context.outputs.env] }}
          atlas_api_key_id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-context.outputs.env] }}

  call-apply:
    needs: create-context
    if: ${{ github.event.comment.body && startsWith(github.event.comment.body, '/apply') }}
    strategy:
      matrix:
        context: ${{ fromJson(needs.create-context.outputs.contexts) }}
    runs-on: ubuntu-22.04
    steps:
      - name: demo call plan
        run: |
          echo ${target_path}
          echo ${mode}
          echo ${env}
          echo ${role_to_assume}
          echo ${atlas_api_key_id}
        env:
          target_path: ${{ fromJson(matrix.context).target_path }}
          mode: ${{ fromJson(matrix.context).mode }}
          env: ${{ needs.create-context.outputs.env }}
          role_to_assume: ${{ fromJson(env.PLAN_ROLE_MAP)[needs.create-context.outputs.env] }}
          atlas_api_key_id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-context.outputs.env] }}

