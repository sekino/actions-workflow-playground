name: adhoc terraform execute

on:
  issue_comment:
    types: [ created ]
  pull_request:
    branches:
      - main
    types: [closed]

env:
  PLAN_ROLE_MAP: '{ "dev": "role/terraformPlan", "stg": "role/terraformPlan" }'
  APPLY_ROLE_MAP: '{ "dev": "role/terraformApply", "stg": "role/terraformApply" }'
  # bitwarden: Mongo Atlas API Key terraform
  ATLAS_API_KEY_ID_MAP: '{ "dev": "123456", "stg": "78910" }'

jobs:
  create-context-plan:
    if: ${{ github.event.comment.body && startsWith(github.event.comment.body, '/target') }}
    runs-on: ubuntu-22.04
    steps:
      - name: Create context
        shell: bash {0}
        id: create-context
        run: |
          target_lines=$(echo "${{ github.event.comment.body }}" | grep -E -w 'plan|plan-destroy' | sort | uniq)
          target_env=$(echo "${target_lines}" | grep -E -ow 'dev|stg|prd|sbg' | sort | uniq)
          
          if [[ -z "${target_lines}" ]]; then
            echo "targets is empty"
            exit 0
          fi
          
          if [[ -z "${target_env}" ]]; then
            echo "cannot find env in target" >&2
            exit 1
          fi
          
          target_env_num=$(echo ${target_env} | wc -l | tr -d ' ')
          if [[ "${target_env_num}" != "1" ]]; then
            echo "two or more env in target" >&2
            exit 1
          fi

          context_array=()
          while IFS= read -r target_line; do
            mode="$(echo ${target_line} | cut -d ' ' -f1 | tr -d ' ')"
            target_path="$(echo ${target_line} | cut -d ' ' -f2 | tr -d ' ' | sed -e "s%/$%%g" | sed -e "s/[\r\n]\+//g" )"
            context="{ \"target_path\": \"${target_path}\", \"mode\": \"${mode}\" }"
            context_array+=("${context}")
          done <<< "${target_lines}" 
          context_json=$(jq --compact-output --null-input '$ARGS.positional' --args -- "${context_array[@]}")

          echo "target_env: ${target_env}"
          echo "target_lines: ${target_lines}"
          echo "contexts: ${context_json}"

          echo "contexts=${context_json}" >> $GITHUB_OUTPUT
          echo "env=${target_env}" >> $GITHUB_OUTPUT
    outputs:
      contexts: ${{ steps.create-context.outputs.contexts }}
      env: ${{ steps.create-context.outputs.env }}

  create-context-apply:
    if: ${{ github.event.comment.body && startsWith(github.event.comment.body, '/target') }}
    runs-on: ubuntu-22.04
    steps:
      - name: Get latest target comment
        id: latest-target-comment
        uses: actions/github-script@v6.3.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            })
            
            // 最新のtargetコメントを使用する
            const targetComment = comments.reverse.find(comment => {
              return comment.body.startsWith("/target")
            })
            
            if (targetComment) return targetComment.body

      - name: Create context
        shell: bash {0}
        id: create-context
        run: |
          echo "${{ steps.latest-target-comment.outputs.result }}"

  call-plan:
    needs: create-context-plan
    strategy:
      matrix:
        context: ${{ fromJson(needs.create-context-plan.outputs.contexts) }}
    if: ${{ needs.create-context-plan.outputs.contexts }}
    runs-on: ubuntu-22.04
    steps:
      - name: demo
        run: |
          echo ${target_path}
          echo ${mode}
          echo ${env}
          echo ${role_to_assume}
          echo ${atlas_api_key_id}
        env:
          target_path: ${{ fromJson(matrix.context).target_path }}
          mode: ${{ fromJson(matrix.context).mode }}
          env: ${{ needs.create-context-plan.outputs.env }}
          role_to_assume: ${{ fromJson(env.PLAN_ROLE_MAP)[needs.create-context-plan.outputs.env] }}
          atlas_api_key_id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-context-plan.outputs.env] }}

#  call-apply:
#    needs: create-tf-execute-context
#    if: ${{ github.event.pull_request.merged == true && needs.create-tf-execute-context.outputs.targets && needs.create-tf-execute-context.outputs.targets != '[]' }}
#    strategy:
#      matrix:
#        state_dir: ${{fromJson(needs.create-tf-execute-context.outputs.targets)}}
#    uses: ./.github/workflows/apply.yml
#    with:
#      role-to-assume: ${{ fromJson(env.APPLY_ROLE_MAP)[needs.create-tf-execute-context.outputs.env] }}
#      work-dir: ${{ matrix.state_dir }}
#      env: ${{ needs.create-tf-execute-context.outputs.env }}
#      atlas-api-key-id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-tf-execute-context.outputs.env] }}
#    secrets:
#      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
#      MODULE_TOKEN: ${{ secrets.MABOT_TOKEN }}
