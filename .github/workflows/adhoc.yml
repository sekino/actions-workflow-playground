name: adhoc terraform execute

on:
  issue_comment:
    types: [ created ]
  pull_request:
    branches:
      - main
    types: [closed]

env:
  PLAN_ROLE_MAP: '{ "dev": "role/terraformPlan", "stg": "role/terraformPlan" }'
  APPLY_ROLE_MAP: '{ "dev": "role/terraformApply", "stg": "role/terraformApply" }'
  # bitwarden: Mongo Atlas API Key terraform
  ATLAS_API_KEY_ID_MAP: '{ "dev": "123456", "stg": "78910" }'

jobs:
  create-context-plan:
    if: ${{ github.event.comment.body && startsWith(github.event.comment.body, '/target') }}
    runs-on: ubuntu-22.04
    steps:
      - name: Create context
        shell: bash {0}
        id: create-context
        run: |
          target_lines=$(echo "${{ github.event.comment.body }}" | grep -E -w 'plan|plan-destroy' | sort | uniq)
          target_env=$(echo "${target_lines}" | grep -E -ow 'dev|stg|prd|sbg' | sort | uniq)
          
          if [[ -z "${target_lines}" ]]; then
            echo "targets is empty"
            exit 0
          fi
          
          if [[ -z "${target_env}" ]]; then
            echo "cannot find env in target" >&2
            exit 1
          fi
          
          target_env_num=$(echo ${target_env} | wc -l | tr -d ' ')
          if [[ "${target_env_num}" != "1" ]]; then
            echo "two or more env in target" >&2
            exit 1
          fi

          context_array=()
          echo "${target_lines}" | while IFS= read -r line; do
            echo "line:${target_line}"
            echo ${target_line} | cut -d ' ' -f1 | tr -d ' '
            echo ${target_line} | cut -d ' ' -f2 | tr -d ' ' | sed -e "s%/$%%g"
          done
          context_json=$(path_list=$(jq --compact-output --null-input '$ARGS.positional' --args -- "${context_array[@]}"))

          echo "target_env: ${target_env}"
          echo "target_lines: ${target_lines}"
          echo "contexts: ${context_json}"

          echo "contexts=${context_json}" >> $GITHUB_OUTPUT
          echo "env=${target_env}" >> $GITHUB_OUTPUT
    outputs:
      contexts: ${{ steps.create-context.outputs.contexts }}
      env: ${{ steps.create-context.outputs.env }}

  call-plan:
    needs: create-context-plan
    strategy:
      matrix:
        context: ${{ fromJson(needs.create-context-plan.outputs.context) }}
    if: ${{ needs.create-context-plan.outputs.context }}
    runs-on: ubuntu-22.04
    steps:
      - name: demo
        run: |
          echo ${target_path}
          echo ${mode}
        env:
          target_path: ${{ matrix.context.target_path }}
          mode: ${{ matrix.context.mode }}
          env: ${{ needs.create-context-plan.outputs.env }}
          role-to-assume: ${{ fromJson(env.PLAN_ROLE_MAP)[needs.create-context-plan.outputs.env] }}
          atlas-api-key-id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-context-plan.outputs.env] }}

#  call-apply:
#    needs: create-tf-execute-context
#    if: ${{ github.event.pull_request.merged == true && needs.create-tf-execute-context.outputs.targets && needs.create-tf-execute-context.outputs.targets != '[]' }}
#    strategy:
#      matrix:
#        state_dir: ${{fromJson(needs.create-tf-execute-context.outputs.targets)}}
#    uses: ./.github/workflows/apply.yml
#    with:
#      role-to-assume: ${{ fromJson(env.APPLY_ROLE_MAP)[needs.create-tf-execute-context.outputs.env] }}
#      work-dir: ${{ matrix.state_dir }}
#      env: ${{ needs.create-tf-execute-context.outputs.env }}
#      atlas-api-key-id: ${{ fromJson(env.ATLAS_API_KEY_ID_MAP)[needs.create-tf-execute-context.outputs.env] }}
#    secrets:
#      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
#      MODULE_TOKEN: ${{ secrets.MABOT_TOKEN }}
